---
title: "Dimensional reduction of mouse models - Supplementary Figures"
author: Correspondence - t.konopka@qmul.ac.uk
output:
  pdf_document:
    keep_tex: true
header-includes:
  \usepackage{caption}
  \usepackage{float}
  \usepackage{amsmath}
  \usepackage{graphicx}
  \floatplacement{figure}{H}
  \captionsetup[figure]{labelfont={bf}, name={Figure}, labelsep=period}
---


```{r, prep, echo=FALSE}
source("config.R")
set.seed(1234)
source("CE_prep_ontology.R")
source("CE_prep_models.R")
source("CE_prep_diseases.R")
```

```{r, embeddings, echo=FALSE}
source("CE_embeddings_ontology.R")
source("CE_embeddings_models.R")
source("CE_node2vec.R")
source("CE_predictions.R")
source("CE_genes.R")
```

```{r, graphics.details, echo=FALSE}
source("CE_wrappers.R")
# optionally set drawing to png
knitr::opts_chunk$set(dpi=600, dev="png", dev.args=list(type="cairo-png"))
#
# set detail for embedding plot
# set < 1 for quick rendering and =1 for final figures (png)
#EMBEDDING_DETAIL <- 0.1
EMBEDDING_DETAIL <- 1
```


\renewcommand{\thefigure}{S\arabic{figure}}
\setcounter{figure}{0}


```{r schematic_methods1, echo=FALSE}
plot_schematic_methods1 <- function() {
  plot_schematic_blank(height=0.8)
  # column with raw data
  add_schematic_line_header("Raw data", c(0, 0.3), 1)
  text(0, 0.92, "Ontology", Rcssclass=c("schematic", "subheading"))
  add_schematic_ontology(c(0.15, 0.87), width=0.16, height=0.14)
  text(0.15, 0.64, "+ term names, descriptions", Rcssclass=c("schematic", "center"))
  #
  # column with encoding cartoons
  add_schematic_line_header("Encoding", c(0.35, 0.65), 1)
  text(0.35, 0.92, "Text", Rcssclass=c("schematic", "subheading"))
  add_schematic_term_description(c(0.35,0.86),
                                 mp_raw[c("MP:0001967", "MP:0001393")],
                                 max.width=0.23, max.lines=5, indent=0.09)
  text(0.35, 0.4, "Graph", Rcssclass=c("schematic", "subheading"))
  add_schematic_ontology(c(0.5, 0.38), width=0.16, height=0.14)
  #
  # labels with embedding algorithms
  add_schematic_line_header("Embedding", c(0.7, 1), 1)
  text_algorithm <- function(...) { text(..., Rcssclass=c("schematic", "algorithm")) }
  text_algorithm(0.85, 0.7, "bag of kmers + nearest neighbors + UMAP")
  text_algorithm(0.85, 0.32, "node2vec")
  #
  # dividers
  lines(rep(0.325, 2), c(-1.5, 1), Rcssclass=c("schematic", "divider"))
  lines(c(0.35, 1), rep(0.47, 2), Rcssclass=c("schematic", "divider"))
}
```


```{r schematic_methods2, echo=FALSE}
plot_schematic_methods2 <- function() {
  plot_schematic_blank(height=1.35)
  # column with raw data
  add_schematic_line_header("Raw data", c(0, 0.3), 1)
  text(0, 0.92, "Ontology", Rcssclass=c("schematic", "subheading"))
  add_schematic_ontology(c(0.15, 0.87), width=0.16, height=0.14)
  text(0.15, 0.64, "+ term names, descriptions", Rcssclass=c("schematic", "center"))
  text(0, 0.49, "Model phenotypes", Rcssclass=c("schematic", "subheading"))
  dummy_phenotypes <- matrix("", ncol=2, nrow=4)
  colnames(dummy_phenotypes) <- c("model", "phenotype")
  dummy_phenotypes[,1] <- c("model A", "model B", "model B", "...")
  dummy_phenotypes[,2] <- c("MP:0001967", "MP:0001967", "MP:0001393", "...")
  add_schematic_table(c(0.15, 0.43), dummy_phenotypes, max.width=0.18)
  #
  # column with encoding cartoons
  add_schematic_line_header("Encoding", c(0.35, 0.65), 1)
  dummy_nonbinary <- matrix(0.1, ncol=10, nrow=2)
  rownames(dummy_nonbinary) <- c("model A  ", "model B  ")
  colnames(dummy_nonbinary) <- c("root", paste0("mid_", 1:3), paste0("leaf_", 1:6))
  dummy_binary <- dummy_nonbinary
  dummy_nonbinary[, "root"] <- 1
  dummy_nonbinary[, c("mid_1", "mid_2", "mid_3")] <- 0.4
  dummy_nonbinary["model A  ", "mid_1"] <- 0.7
  dummy_nonbinary["model B  ", "mid_1"] <- 0.7
  dummy_nonbinary["model B  ", "mid_2"] <- 0.6
  dummy_nonbinary["model A  ", "leaf_1"] <- 0.55
  dummy_nonbinary["model B  ", "leaf_1"] <- 0.55
  dummy_nonbinary["model B  ", "leaf_4"] <- 0.4
  dummy_binary[dummy_binary>0] <- 0
  dummy_binary["model A  ", c("root", "mid_1", "leaf_1")] <- 1
  dummy_binary["model B  ", c("root", "mid_1", "leaf_1", "mid_2", "leaf_4")] <- 1
  text(0.35, 0.92, "Vector (non-binary)", Rcssclass=c("schematic", "subheading"))
  add_schematic_heatmap(c(0.55, 0.87), dummy_nonbinary, width=0.16, height=0.09)
  text(0.35, 0.67, "Vector (binary)", Rcssclass=c("schematic", "subheading"))
  add_schematic_heatmap(c(0.55, 0.62), dummy_binary, width=0.16, height=0.09)
  #
  text(0.35, 0.42, "Graph", Rcssclass=c("schematic", "subheading"))
  model_A <- c(0.43, 0.33)
  text(model_A[1], model_A[2], "model A", Rcssclass=c("schematic", "model"))
  lines(c(model_A[1], 0.475), c(model_A[2], 0.27), Rcssclass=c("schematic", "ontology"))
  points(model_A[1], model_A[2], Rcssclass=c("schematic", "model"))
  model_B <- c(0.48, 0.42)
  text(model_B[1], model_B[2], "model B", Rcssclass=c("schematic", "model"))
  lines(c(model_B[1], 0.47), c(model_B[2], 0.27), Rcssclass=c("schematic", "ontology"))
  lines(c(model_B[1], 0.535), c(model_B[2], 0.27), Rcssclass=c("schematic", "ontology"))
  points(model_B[1], model_B[2], Rcssclass=c("schematic", "model"))
  add_schematic_ontology(c(0.55, 0.42), width=0.16, height=0.14)
  text(0.35, 0.17, "Text (concise phenotypes)", Rcssclass=c("schematic", "subheading"))
  dummy_concise <- list(A=list(data=list(name="deafness"),
                               metadata=list(id="model A")),
                        B=list(data=list(name="deafness, ataxia"),
                               metadata=list(id="model B")))
  add_schematic_term_description(c(0.4, 0.10), dummy_concise,
                                 max.width=0.23, max.lines=5, indent=0.06)
  text(0.35, -0.08, "Text (complete phenotypes)", Rcssclass=c("schematic", "subheading"))
  dummy_complete <- list(A=list(data=list(name="deafness",
                                          parents=c("abnormal ear physiology, ...")),
                                metadata=list(id="model A")),
                         B=list(data=list(name=c("deafness, ataxia"),
                                          parents=c("abnormal ear physiology, ...",
                                                    "abnormal locomotor behavior, ...")),
                                metadata=list(id="model B")))
  add_schematic_term_description(c(0.4, -0.14), dummy_complete,
                                 max.width=0.23, max.lines=5, indent=0.06)
  #
  # labels with embedding algorithms
  add_schematic_line_header("Embedding", c(0.7, 1), 1)
  text_algorithm <- function(...) { text(..., Rcssclass=c("schematic", "algorithm")) }
  text_algorithm(0.85, 0.86, "nearest neighbors + UMAP")
  text_algorithm(0.85, 0.79, "PCA")
  text_algorithm(0.85, 0.6, "nearest neighbors + UMAP")
  text_algorithm(0.85, 0.35, "node2vec")
  text_algorithm(0.85, 0.1, "bag of kmers + nearest neighbors + UMAP")
  text_algorithm(0.85, -0.2, "bag of kmers + nearest neighbors + UMAP")
  #
  # dividers
  lines(rep(0.325, 2), c(-1.5, 1), Rcssclass=c("schematic", "divider"))
  lines(c(0.35, 1), rep(0.73, 2), Rcssclass=c("schematic", "divider"))
  lines(c(0.35, 1), rep(0.48, 2), Rcssclass=c("schematic", "divider"))
  lines(c(0.35, 1), rep(0.23, 2), Rcssclass=c("schematic", "divider"))
  lines(c(0.35, 1), rep(-0.02, 2), Rcssclass=c("schematic", "divider"))
}
```



```{r supfig.mp, eval=TRUE, echo=FALSE, fig.width=6.5, fig.height=4.1, fig.cap="\\textbf{Embeddings of mammalian phenotype ontology terms.} \\textbf{(A)} Schematic of ontology data, possibilities for numerical encoding, and algorithms for creating embeddings. \\textbf{(B)} Embedding based on text descriptions (name, definition, synonyms, comments, and name of parent term). Similarities computed using crossmap and layout generated with UMAP. \\textbf{(C)} Embedding based on the hierarchy relations between ontology terms, generated using snap implementation of node2vec with default settings. \\textbf{(D)} Embedding based on the ontology hierachy graph, generated using python implementation of node2vec with default settings. \\textbf{(E)} Similar to E, generated with non-default settings with walk-length and num-walks set to 5."}
layout(matrix(c(1,1,1,1,1,1,1,
                2,2,2,2,2,2,2,
                3,7,4,7,5,7,6),
              ncol=7, nrow=3, byrow=T),
       widths=c(1.6, 0.04, 1.6, 0.04, 1.6, 0.04, 1.6),
       height=c(1.8, 0.7, 1.6))
plot_schematic_methods1()
multipanelLabel(panel.labels[1])
#
wrap_separate_legend("bottomleft", c(other="MP term"), width=0.34,
                     main="Embeddings of mouse phenotype ontology terms")
#
# crossmap and umap embedding
plot_embedding(mp_embedding$d2[label=="mp"],
               main=" Text descriptions",
               detail=max(0.5, EMBEDDING_DETAIL),
               Rcssclass="mp")
multipanelLabel(panel.labels[2])
#
# node2vec embedding
for (.encoding in c("snap", "defaults", "short")) {
  .main <- "Graph (snap, default)"
  if (.encoding=="defaults") {
    .main <- "Graph (python, default)"
  } else if (.encoding=="short") {
    .main <- "Graph (python, short walks)"
  }
  plot_embedding(node2vec_embedding[[.encoding]]$mp_ontology[label=="mp",],
                 xy=c("node2vec_1", "node2vec_2"),
                 xlab="node2vec 1", ylab="node2vec 2",
                 main=paste0(" ", .main),
                 detail=max(0.5, EMBEDDING_DETAIL),
                 Rcssclass="mp")
  #add_embedding_legend("bottomleft", c(mp="MP term"))
  multipanelLabel(panel.labels[2+which(c("snap", "defaults", "short")==.encoding)])
}
rm(.encoding, .main)
par(mai=rep(0.1, 4)); plot(c(0,1), c(0, 1), type="n")
```


```{r supfig.models.encodings, eval=TRUE, echo=FALSE, fig.width=6.5, fig.height=6.9, fig.cap="\\textbf{Embeddings of mouse models.} \\textbf{(A)} Schematic of phenotype data for mouse models, data encoding possibilities, and algorithms for creating embeddings. \\textbf{(B)} UMAP embedding based on non-binary vector representations. \\textbf{(C)} PCA based on non-binary vector representations. \\textbf{(D)} UMAP embedding based on binary vector representations.  \\textbf{(E)} Node2vec embedding based on a graph connecting mouse models to their ontology phenotypes, generated using snap implementation of node2vec with default settings. \\textbf{(F)} Similar to (E), generated using python implementation of node2vec with default settings. \\textbf{(G)} Similar to (E), generated with python implementation of node2vec with non-default settings using walk-length and num-walks set to 5. \\textbf{(H)} Embedding based on text descriptions of mouse phenotypes. \\textbf{(I)} Similar to (H), but using text descriptions of complete phenotypes."}
layout(matrix(c(1,1,1,1,1,1,1,
                2,2,2,2,2,2,2,
                3,11,4,11,5,11,6,
                rep(11,7),
                7,11,8,11,9,11,10),
              ncol=7, nrow=5, byrow=T),
       widths=c(1.6, 0.04, 1.6, 0.04, 1.6, 0.04, 1.6), height=c(2.9, 0.7, 1.6, 0.1, 1.6))
#
plot_schematic_methods2()
multipanelLabel(panel.labels[1])
#
wrap_separate_legend("bottomleft", c(other="mouse model"),
                     main="Embeddings of mouse models", width=0.22)
#
# sub-panels with different encodings
.encoding_main <- c(
  vector="Vector (non-binary)",
  pca="PCA (non-binary)",
  binvector="Vector (binary)",
  snap="Graph (snap)",
  defaults="Graph (python, default)",
  short="Graph (python, short walks)",
  text_concise_diff0="Text (concise)",
  text_complete_diff0="Text (complete)"
)
for (.encoding in names(.encoding_main)) {
  .main <- paste0(" ", .encoding_main[.encoding])
  if (.encoding %in% names(model_umap_embedding)) {
    plot_embedding(model_umap_embedding[[.encoding]][label=="model" & id %in% models_w_phen$gt_1],
                   main=.main, detail=EMBEDDING_DETAIL,
                   Rcssclass=c("large", "models"))
  } else if (grepl("pca", .encoding)) {
    plot_embedding(model_pca_embeddings_d$vector$d2[label=="model" & id %in% models_w_phen$gt_1],
                   xy=c("PCA_1", "PCA_2"),
                   xlab="PCA 1", ylab="PCA 2",
                   main=.main, detail=EMBEDDING_DETAIL,
                   Rcssclass=c("large", "models"))
  } else {
    plot_embedding(node2vec_embedding[[.encoding]]$mouse_model_concise[label=="model" & id %in% models_w_phen$gt_1],
                   xy=c("node2vec_1", "node2vec_2"),
                   xlab="node2vec 1", ylab="node2vec 2",
                   main=.main, detail=EMBEDDING_DETAIL,
                   Rcssclass=c("large", "models"))
  }
  multipanelLabel(panel.labels[1+which(names(.encoding_main)==.encoding)])
}
rm(.encoding, .main, .encoding_main)
```


```{r supfig.models.covariates, eval=TRUE, echo=FALSE, fig.width=6.4, fig.height=6.4, fig.cap="\\textbf{Mouse model covariates.} All panels show embeddings of mouse models based on non-binary vectors of phenotypes. Panels differ by stratification strategy: \\textbf{(A)} phenotyping source; \\textbf{(B)} number of registered phenotypes; \\textbf{(C)} animal genetic background; \\textbf{(D)} zygosity of gene knock-out."}
layout(matrix(c(1,2,3,
                4,4,4,
                5,6,7),
              ncol=3, nrow=3, byrow=T),
       widths=c(3.15, 0.1, 3.15), height=c(3.15, 0.1, 3.15))
#
# sub-panels with different encodings
.emb <- model_umap_embedding$vector[label=="model" & id %in% models_w_phen$gt_1]
.emb <- merge(.emb, model_info, by.x="id", by.y="model_id")
discretize_base2 <- function(x) {
  result <- rep("range_0_0", length(x))
  result[x>0 & x<=2] <- "range_0_2"
  result[x>2 & x<=4] <- "range_2_4"
  result[x>4 & x<=8] <- "range_4_8"
  result[x>8 & x<=16] <- "range_8_16"
  result[x>16 & x<=32] <- "range_16_32"
  result[x>32 ] <- "range_32_max"
  result
}
discretize_bg <- function(x) {
  result <- rep("other", length(x))
  result[grep("Not.Specified", x)] <- "not_specified"
  result[grep("C57BL.6", x)] <- "C57BL_6"
  result[grep("C57BL.6N$", x)] <- "C57BL_6N"
  result[grep("C57BL.6NJ$", x)] <- "C57BL_6NJ"
  result[grep("C57BL.6NCrl$", x)] <- "C57BL_6NCrl"
  result[grep("C57BL.6NTac$", x)] <- "C57BL_6NTac"
  result
}
discretize_zygosity <- function(x) {
  result <- sapply(strsplit(x, "/"), function(z) {
    if (length(z)!=2) return("other")
    if (z[1]==z[2]) return("hom")
    return("other")
  })
  as.character(result)
}
.emb$discrete_phens <- discretize_base2(.emb$num_phenotypes)
.emb$discrete_bg <- discretize_bg(.emb$genetic_background)
.emb$discrete_zygosity <- discretize_zygosity(.emb$model_description)
#
# data sources (MGI/IMPC)
plot_embedding(.emb, style_by="bin_source",
               main="Data source",
               detail=EMBEDDING_DETAIL, Rcssclass=c("large", "vlarge"))
add_embedding_legend("topleft",
                     c(MGI="MGI mouse model", nonMGI="IMPC mouse model"))
multipanelLabel(panel.labels[1])
par(mai=rep(0.01, 4)); plot.new()
#
# number of phenotypes
plot_embedding(.emb, style_by="discrete_phens",
               main="Number of phenotypes",
               detail=EMBEDDING_DETAIL, Rcssclass=c("large", "vlarge"))
add_embedding_legend("topleft",
                     c(range_0_2="(0, 2]", range_2_4="(2, 4]",
                       range_4_8="(4, 8]", range_8_16="(8, 16]",
                       range_16_32="(16, 32]", range_32_max="(32, inf]"))
multipanelLabel(panel.labels[2])
par(mai=rep(0.01, 4)); plot.new()
#
# genetic background
plot_embedding(.emb, style_by="discrete_bg",
               main="Genetic background",
               detail=EMBEDDING_DETAIL, Rcssclass=c("large", "vlarge"))
add_embedding_legend("topleft",
                     c(C57BL_6="involves C57BL/6", C57BL_6N="C57BL/6N",
                       C57BL_6NCrl="C57BL/6NCrl", C57BL_6NJ="C57BL/6NJ",
                       C57BL_6NTac="C57BL/6NTac", other="other"),
                     Rcssclass="large")
multipanelLabel(panel.labels[3])
par(mai=rep(0.01, 4)); plot.new()
#
# zygosity
plot_embedding(.emb, style_by="discrete_zygosity",
               main="Zygosity",
               detail=EMBEDDING_DETAIL, Rcssclass=c("large", "vlarge"))
add_embedding_legend("topleft",
                     c(hom="homozygous", other="other"),
                     Rcssclass="large")
multipanelLabel(panel.labels[4])
rm(.emb)
```


```{r supfig.models.enrichment, eval=TRUE, echo=FALSE, fig.width=6.5, fig.height=7.8, fig.cap="\\textbf{Feature enrichment in embedding regions.} \\textbf{(A)} Embedding of all mouse models based on their phenotypes. Two regions are selected with rectangular gates.  \\textbf{(B)} A detailed view of one of the gated regions from (A). \\textbf{(C)} Enrichment analysis comparing phenotypes observed in animal models shown in (B) compared to all other models outside the gated region. Dots correspond to MP phenotypes. Axes show the fraction of selected models with a given phenotype, and an enrichment significance score for the phenotype computed using a Fisher test (some p-values are truncated). Significance level is $p=0.05$ after Bonferroni correction. The table on the right names the most significant phenotypes. \\textbf{(D, E)} Analogous to (B, C), but treating another gated region. \\textbf{(F-J)} Analogous to (A-J), but based on an embedding of mouse models based on concise text descriptions. "}
layout(matrix(c(1,1, 16, 2, 2,
                3,3, 16, 3, 3,
                4,7, 16, 10,13,
                5,8, 16, 11,14,
                6,9, 16, 12,15),
              ncol=5, nrow=5, byrow=T),
       widths=c(1.6, 1.6, 0.1, 1.6, 1.6), height=c(3.2, 0.1, 1.5, 1.5, 1.5))
#
# embedding based on vectors
.emb1 <- model_umap_embedding$vector[label=="model" & id %in% models_w_phen$gt_1]
.emb1 <- merge(.emb1, model_info[, c("model_id", "bin_source")],
              by.x="id", by.y="model_id")
.emb1_gate1 <- c(-14, 1.5, -11, 4.5)
.emb1_gate2 <- c(-3, -12.5, 1, -8.5)
.qlim <- c(0.015, 0.985)
#
plot_embedding(.emb1, detail=EMBEDDING_DETAIL, style_by="bin_source",
               qlim=.qlim,
               main=" Embedding of mouse models\n (non-binary vectors of MP terms)",
               Rcssclass=c("large", "vlarge", "title2"))
rect(.emb1_gate1[1], .emb1_gate1[2], .emb1_gate1[3], .emb1_gate1[4],
     Rcssclass="embedding")
rect(.emb1_gate2[1], .emb1_gate2[2], .emb1_gate2[3], .emb1_gate2[4],
     Rcssclass="embedding")
add_embedding_legend("bottomleft", c(MGI="MGI mouse model", nonMGI="IMPC mouse model"))
multipanelLabel(panel.labels[1])
#
# another embedding based on text
.emb2 <- model_umap_embedding$text_concise_diff0[label=="model" &
                                                        id %in% models_w_phen$gt_1]
.emb2 <- merge(.emb2, model_info[, c("model_id", "bin_source")],
              by.x="id", by.y="model_id")
#.emb2_gate1 <- c(-9, 3, -6, 6)
.emb2_gate1 <- c(-3, 5.5, -1, 7.5)
.emb2_gate2 <- c(1.5, -4, 4, -1.5)
#
plot_embedding(.emb2, detail=EMBEDDING_DETAIL, style_by="bin_source",
               qlim=.qlim,
               main=" Embedding of mouse models\n (text of concise phentypes)",
               Rcssclass=c("large", "vlarge", "title2"))
rect(.emb2_gate1[1], .emb2_gate1[2], .emb2_gate1[3], .emb2_gate1[4],
     Rcssclass="embedding")
rect(.emb2_gate2[1], .emb2_gate2[2], .emb2_gate2[3], .emb2_gate2[4],
     Rcssclass="embedding")
add_embedding_legend("bottomleft", c(MGI="MGI mouse model", nonMGI="IMPC mouse model"))
multipanelLabel(panel.labels[6])
#
# spacer
par(mai=rep(0.01, 4)); plot.new();
#
# gate 1
wrap_embedding_enrichment(.emb1, gate_rect=.emb1_gate1,
                          panel.label=panel.labels[2:3],
                          xlim=c(0, 1), ylim=c(0, 320),
                          show_list=TRUE)
# gate 2
wrap_embedding_enrichment(.emb1, gate_rect=.emb1_gate2,
                          panel.label=panel.labels[4:5],
                          xlim=c(0, 1), ylim=c(0, 320),
                          show_list=TRUE)
# gate 3
wrap_embedding_enrichment(.emb2, gate_rect=.emb2_gate1,
                          panel.label=panel.labels[7:8],
                          xlim=c(0, 1), ylim=c(0, 320),
                          show_list=TRUE)
# gate 4
wrap_embedding_enrichment(.emb2, gate_rect=.emb2_gate2,
                          panel.label=panel.labels[9:10],
                          xlim=c(0, 1), ylim=c(0, 320),
                          show_list=TRUE)
rm(.emb1, .emb2, .emb1_gate1, .emb1_gate2, .emb2_gate1, .emb2_gate2, .qlim)
```


```{r supfig.models.diseases, eval=TRUE, echo=FALSE, fig.width=6.5, fig.height=6.9, fig.cap="\\textbf{Embeddings of diseases.} \\textbf{(A)} Projection of human disease phenotype profiles (colored points) into an embedding of mouse models (gray dots). The embedding was created based on non-binary vectors with mouse model phenotypes, without information about diseases. Disease phenotype profiles were translated into mammalian phenotype (MP) ontology terms using owlsim, encoded into vectors, and projected into the embedding using UMAP. \\textbf{(B)} Similar to (A), but with the translations between human and mouse phenotypes carried out using crossmap. \\textbf{(C)} Series of three embeddings where human diseases  are projected into an embedding based on text descriptions of mouse models. Descriptions of human diseases consisted of a clinical summary, and translations of phenotypes into mammalian phenotype ontology terms using owlsim. Disease description were projected into the embedding by searching for k=1, k=2, k=5 mouse models and then averaging their coordinates. \\textbf{(D)} Similar to (C), but with translations between human and mouse phenotype carried out using crossmap. "}
layout(matrix(c(1,1,2,
                3,4,5,
                6,6,6,
                7,7,7,
                8,9,10,
                11,11,11,
                12,13,14),
              ncol=3, nrow=7, byrow=T),
       widths=c(2.1, 2.1, 2.1), height=c(0.2, 2.1, 0.2, 0.2, 2.1, 0.1, 2.1))
#
# vector embedding, sub-panels with diseases
.emb1 <- model_umap_embedding$vector
.emb1_models <- .emb1[label=="model" & id %in% models_w_phen$gt_0]
.disease_ids <- .emb1[label=="owlsim"]$id
.qlim <- c(0.02, 0.98)
#
#
plot_line_header("Emeddings based on non-binary vectors of MP terms");
par(mai=rep(0.01, 4)); plot.new();
#
plot_embedding(.emb1_models, detail=max(0.1, EMBEDDING_DETAIL),
               main="", qlim=.qlim, Rcssclass=c("large", "large3"))
points_embedding(.emb1[label=="owlsim"], detail=max(0.2, EMBEDDING_DETAIL),
                 Rcssclass="owlsim")
multipanelLabel(panel.labels[1])
plot_embedding(.emb1_models, detail=max(0.1, EMBEDDING_DETAIL),
               main="", qlim=.qlim, Rcssclass=c("large", "large3"))
points_embedding(.emb1[label=="crossmap"], detail=max(0.2, EMBEDDING_DETAIL),
                 Rcssclass="crossmap")
multipanelLabel(panel.labels[2])
#
par(mai=rep(0.2, 4)); plot(c(0, 1), c(0, 1), type="n", axes=FALSE);
add_embedding_legend(legend_pos="topleft",
                     c(other="Mouse model",
                       owlsim="Human disease (owlsim HP-MP translation)",
                       crossmap="Human disease (crossmap HP-MP translation)")
)
#
# horizontal spacer panel
par(mai=rep(0.01, 4)); plot.new()
#
# text-based embeddings
assignc("disease_search")
.crossmap_search <- disease_search$crossmap$orphanet$text_concise_diff0
.owlsim_search <- disease_search$owlsim$orphanet$text_concise_diff0
.disease_search_k <- list(
        crossmap_k1 = .crossmap_search[, head(.SD, 1), by="query"],
        crossmap_k2 = .crossmap_search[, head(.SD, 2), by="query"],
        crossmap_k5 = .crossmap_search[, head(.SD, 5), by="query"],
        crossmap_k15 = .crossmap_search[, head(.SD, 15), by="query"],
        owlsim_k1 = .owlsim_search[, head(.SD, 1), by="query"],
        owlsim_k2 = .owlsim_search[, head(.SD, 2), by="query"],
        owlsim_k5 = .owlsim_search[, head(.SD, 5), by="query"],
        owlsim_k15 = .owlsim_search[, head(.SD, 15), by="query"]
)
.emb2 <- model_umap_embedding$text_concise_diff0
.emb2_models <- .emb2[label=="model" & id %in% models_w_phen$gt_1]
.emb2_diseases_k <- lapply(
  .disease_search_k,
  function(x) {
    x$id <- x$query
    predict_avg_coordinates(.emb2, x, feature_col="target", label="disease")
  }
)
#
wrap_models_diseases <- function(main, klab, Rcssclass="crossmap") {
  plot_embedding(.emb2_models, detail=max(0.1, EMBEDDING_DETAIL),
                 main=main, qlim=.qlim, Rcssclass=c("large", "large3"))
  points_embedding(.emb2_diseases_k[[klab]][id %in% .disease_ids],
                   detail=max(0.2, EMBEDDING_DETAIL),
                   Rcssclass=Rcssclass)
}
#
plot_line_header("Embeddings based on text descriptions");
# row with owlsim results
wrap_models_diseases(" (k=1)", "owlsim_k1", Rcssclass="owlsim")
multipanelLabel(panel.labels[3])
wrap_models_diseases(" (k=2)", "owlsim_k2", Rcssclass="owlsim")
wrap_models_diseases(" (k=5)", "owlsim_k5", Rcssclass="owlsim")
# row with crossmap results
par(mai=rep(0.01, 4)); plot.new()
wrap_models_diseases(" (k=1)", "crossmap_k1", Rcssclass="crossmap")
multipanelLabel(panel.labels[4])
wrap_models_diseases(" (k=2)", "crossmap_k2", Rcssclass="crossmap")
wrap_models_diseases(" (k=5)", "crossmap_k5", Rcssclass="crossmap")
#
rm(.emb1, .emb1_models, .disease_ids, .qlim)
rm(.emb2, .emb2_models, .emb2_diseases_k, .crossmap_search, .owlsim_search)
```

